{"version":3,"file":"smile-js.js","sources":["../src/main/js/error.ts","../src/main/js/decoder.ts","../src/main/js/decoderStream.ts","../src/main/js/inputStream.ts","../src/main/js/sharedStringBuffer.ts","../src/main/js/parser.ts"],"sourcesContent":["/**\n * SMILE error.\n */\nexport class SmileError extends Error {\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n","import {SmileError} from './error.js';\n\nconst bitMask = [0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff];\n\nexport class Decoder {\n    public decodeVInt(bytes: Uint8Array): number | bigint {\n        if (bytes.length <= 0) {\n            throw new SmileError('invalid VInt');\n        }\n        let value = BigInt(0);\n        for (let i = 0; i < bytes.length; i++) {\n            const n = bytes[i];\n            if (i < (bytes.length - 1)) {\n                if ((n & 0x80) !== 0x00) {\n                    throw new SmileError('invalid VInt');\n                }\n                value = (value * BigInt(128)) + BigInt(n & 0x7f);\n            } else {\n                if ((n & 0x80) !== 0x80) {\n                    throw new SmileError('invalid VInt');\n                }\n                value = (value * BigInt(64)) + BigInt(n & 0x3f);\n                break;\n            }\n        }\n        if ((value >= BigInt(Number.MIN_SAFE_INTEGER)) && (value <= BigInt(Number.MAX_SAFE_INTEGER))) {\n            return Number(value);\n        } else {\n            return value;\n        }\n    }\n\n    public decodeZigZag(value: number | bigint): number | bigint {\n        if (value < 0) {\n            throw new SmileError(\"illegal zigzag value\");\n        }\n        if (typeof value === 'bigint') {\n            if (value <= BigInt(2147483647)) {\n                if ((value % BigInt(2)) === BigInt(1)) {\n                    return Number(-(value >> BigInt(1)) - BigInt(1));\n                } else {\n                    return Number(value >> BigInt(1));\n                }\n            } else {\n                if ((value % BigInt(2)) === BigInt(1)) {\n                    const v = (value - BigInt(1)) / BigInt(2);\n                    return Number(-v - BigInt(1));\n                } else {\n                    const v = value / BigInt(2);\n                    return Number(v);\n                }\n            }\n        } else {\n            if (value <= 2147483647) {\n                if ((value % 2) === 1) {\n                    return -(value >> 1) - 1;\n                } else {\n                    return (value >> 1);\n                }\n            } else {\n                if ((value % 2) === 1) {\n                    return -((value - 1) / 2) - 1;\n                } else {\n                    return value / 2;\n                }\n            }\n        }\n    }\n\n    public decodeAscii(bytes: Uint8Array): string {\n        return new TextDecoder('ascii').decode(bytes);\n    }\n\n    public decodeUtf8(bytes: Uint8Array): string {\n        return new TextDecoder('utf8').decode(bytes);\n    }\n\n    private toDataView(bytes: Uint8Array): DataView {\n        const buffer = new ArrayBuffer(bytes.length);\n        const view = new DataView(buffer);\n        for (let i = 0; i < bytes.length; i++) {\n            view.setUint8(i, bytes[i])\n        }\n        return view;\n    }\n\n    // big-endian encoding\n    public decodeFloat32(bytes: Uint8Array): number {\n        return this.toDataView(bytes).getFloat32(0, false);\n    }\n\n    // big-endian encoding\n    public decodeFloat64(bytes: Uint8Array): number {\n        return this.toDataView(bytes).getFloat64(0, false);\n    }\n\n    public decodeFixedLengthBigEndianEncodedBits(bytes: Uint8Array, bits: number): Uint8Array {\n        const output = new Uint8Array(Math.ceil(bits / 8));\n        let iByte = 0;\n        let iBitsRemaining = bits % 7;\n        let oByte = 0;\n        let oBitsWritten = 0;\n        let currentInput = bytes[iByte];\n        let currentOutput = 0;\n        let oIndex;\n        while (iByte < bytes.length) {\n            const bitsToWrite = Math.min(iBitsRemaining, (8 - oBitsWritten));\n            currentOutput <<= bitsToWrite;\n            currentOutput |= currentInput >> (iBitsRemaining - bitsToWrite);\n            iBitsRemaining -= bitsToWrite;\n            currentInput &= bitMask[iBitsRemaining];\n            oBitsWritten += bitsToWrite;\n            if (iBitsRemaining === 0) {\n                iByte++;\n                iBitsRemaining = 7;\n                currentInput = bytes[iByte];\n            }\n            if (oBitsWritten === 8) {\n                oIndex = oByte;\n                output[oIndex] = currentOutput;\n                oByte++;\n                oBitsWritten = 0;\n                currentOutput = 0;\n            }\n        }\n        if (oBitsWritten > 0) {\n            currentOutput <<= (8 - oBitsWritten);\n            oIndex = oByte;\n            output[oIndex] = currentOutput;\n        }\n        return output;\n    }\n\n    public decodeSafeBinaryEncodedBits(bytes: Uint8Array, bits: number): Uint8Array {\n        const output = new Uint8Array(Math.ceil(bits / 8));\n        let iByte = 0;\n        let iBitsRemaining = 7;\n        let oByte = 0;\n        let oBitsWritten = 0;\n        let currentInput = bytes[iByte];\n        let currentOutput = 0;\n        while (oByte < output.length) {\n            const bitsToWrite = Math.min(iBitsRemaining, (8 - oBitsWritten));\n            currentOutput <<= bitsToWrite;\n            currentOutput |= currentInput >> (iBitsRemaining - bitsToWrite);\n            iBitsRemaining -= bitsToWrite;\n            currentInput &= bitMask[iBitsRemaining];\n            oBitsWritten += bitsToWrite;\n            if (iBitsRemaining === 0) {\n                iByte++;\n                iBitsRemaining = 7;\n                currentInput = bytes[iByte];\n            }\n            if (oBitsWritten === 8) {\n                output[oByte] = currentOutput;\n                oByte++;\n                oBitsWritten = 0;\n                currentOutput = 0;\n            }\n        }\n        if (oBitsWritten > 0) {\n            currentOutput <<= (8 - oBitsWritten);\n            output[oByte] = currentOutput;\n        }\n        return output;\n    }\n}\n","import {InputStream} from './inputStream.js';\nimport {Decoder} from './decoder.js';\nimport {SmileError} from './error.js';\n\nexport class DecoderStream {\n    private readonly inputStream: InputStream;\n    private readonly decoder: Decoder;\n\n    constructor(inputStream: InputStream) {\n        this.inputStream = inputStream;\n        this.decoder = new Decoder();\n    }\n\n    public isEof(): boolean {\n        return this.inputStream.isEof();\n    }\n\n    public read(): number {\n        return this.inputStream.read();\n    }\n\n    public peek(): number {\n        return this.inputStream.peek();\n    }\n\n    private readVIntBytes(): Uint8Array {\n        const bytes: number[] = [];\n        while (true) {\n            const n = this.read();\n            bytes.push(n);\n            if ((n & 0x80) === 0x80) {\n                break;\n            }\n        }\n        return new Uint8Array(bytes);\n    }\n\n    public readUnsignedVint(): number | bigint {\n        const bytes = this.readVIntBytes();\n        return this.decoder.decodeVInt(bytes);\n    }\n\n    public readSignedVint(): number | bigint {\n        return this.decoder.decodeZigZag(this.readUnsignedVint());\n    }\n\n    public readAscii(len: number): string {\n        return this.decoder.decodeAscii(this.inputStream.readArray(len));\n    }\n\n    public readUtf8(len: number): string {\n        return this.decoder.decodeUtf8(this.inputStream.readArray(len));\n    }\n\n    public readFloat32(): number {\n        return this.decoder.decodeFloat32(this.readFixedLengthBigEndianEncodedBits(32));\n    }\n\n    public readFloat64(): number {\n        return this.decoder.decodeFloat64(this.readFixedLengthBigEndianEncodedBits(64));\n    }\n\n    public readFixedLengthBigEndianEncodedBits(bits: number): Uint8Array {\n        const bytes = this.inputStream.readArray(Math.ceil(bits / 7));\n        return this.decoder.decodeFixedLengthBigEndianEncodedBits(bytes, bits);\n    }\n\n    public readSafeBinary(): Uint8Array {\n        const len = this.readUnsignedVint();\n        if (typeof(len) === 'bigint') {\n            throw new SmileError('invalid length');\n        }\n        const bytes = this.inputStream.readArray(Math.ceil(len * 8 / 7));\n        return this.decoder.decodeSafeBinaryEncodedBits(bytes, len * 8);\n    }\n\n    public readBigInt(): number {\n        const bytes = this.readSafeBinary();\n        let n = 0;\n        for (let i = 0; i < bytes.length; i++) {\n            n = (n * 256) + bytes[i];\n        }\n        return n;\n    }\n\n    public readBigDecimal(): number {\n        const scale = this.readSignedVint();\n        if (typeof(scale) === 'bigint') {\n            throw new SmileError('invalid scale');\n        }\n        const magnitude = this.readBigInt();\n        return magnitude * Math.pow(10, scale);\n    }\n\n    public readLongString(): Uint8Array {\n        const buffer: number[] = [];\n        while (true) {\n            const c = this.inputStream.read();\n            if (c === 0xfc) {\n                break;\n            }\n            buffer.push(c);\n        }\n        return new Uint8Array(buffer);\n    }\n\n    public readLongAscii() {\n        return this.decoder.decodeAscii(this.readLongString());\n    }\n\n    public readLongUtf8() {\n        return this.decoder.decodeUtf8(this.readLongString());\n    }\n\n    public readBytes(len: number): Uint8Array {\n        return this.inputStream.readArray(len);\n    }\n}\n","import {SmileError} from './error.js';\n\nexport const eofError = new SmileError('end of input stream reached');\n\nexport class InputStream {\n    private readonly array: Uint8Array;\n    private index: number = 0;\n\n    constructor(array: Uint8Array) {\n        this.array = array;\n    }\n\n    public isEof(): boolean {\n        return (this.index >= this.array.length);\n    }\n\n    public read(): number {\n        if (this.isEof()) {\n            throw eofError;\n        }\n        const v = this.array[this.index];\n        this.index++;\n        return v;\n    }\n\n    public readArray(n: number): Uint8Array {\n        if (this.isEof()) {\n            throw eofError;\n        }\n        if (n < 0) {\n            throw new SmileError('invalid read amount');\n        }\n        const endIndex = Math.min(this.array.length, this.index + n);\n        const readData = this.array.subarray(this.index, endIndex);\n        this.index = endIndex;\n        return readData;\n    }\n\n    public peek(): number {\n        if (this.isEof()) {\n            throw eofError;\n        }\n        return this.array[this.index];\n    }\n\n    public skip(n: number) {\n        if (this.isEof()) {\n            throw eofError;\n        }\n        if (n < 0) {\n            throw new SmileError('invalid skip amount');\n        }\n        this.index += n;\n    }\n}\n","import {SmileError} from './error.js';\n\nexport class SharedStringBuffer {\n    private readonly name: string;\n    private readonly keyMode: boolean;\n    private readonly enabled: boolean;\n    private readonly maxStrings: number;\n    private strings: string[];\n    private stringMap: { [key: string]: number };\n\n    constructor(name: string, keyMode: boolean, enabled: boolean, maxStrings: number) {\n        this.name = name;\n        this.keyMode = keyMode;\n        this.enabled = enabled;\n        this.maxStrings = maxStrings;\n        this.reset();\n        this.strings = [];\n        this.stringMap = {};\n        this.reset();\n    }\n\n    private reset(): void {\n        //console.log(`[${this.name}] ssb: reset`);\n        if (this.keyMode) {\n            this.strings = [];\n            this.stringMap = {};\n        } else {\n            this.strings = [''];\n            this.stringMap = {};\n        }\n    }\n\n    public static newValues(enabled: boolean): SharedStringBuffer {\n        return new SharedStringBuffer('values', false, enabled, 1024);\n    }\n\n    public static newKeyNames(enabled: boolean): SharedStringBuffer {\n        return new SharedStringBuffer('keyNames', true, enabled, 1024);\n    }\n\n    public addString(s: string): number {\n        if (!this.enabled) {\n            return -1;\n        }\n        const bytes = new TextEncoder().encode(s);\n        if (bytes.length > 64) {\n            return -1;\n        }\n        if (s in this.stringMap) {\n            return this.stringMap[s];\n        }\n        if (this.keyMode) {\n            if (this.strings.length >= this.maxStrings) {\n                this.reset();\n            }\n        } else {\n            if (this.strings.length > this.maxStrings) {\n                this.reset();\n            }\n        }\n        const index = this.strings.length;\n        //console.log(`[${this.name}] ssb: add [${index}] '${s}'`);\n        this.strings.push(s);\n        this.stringMap[s] = index;\n        return index;\n    };\n\n    public getString(index: number): string {\n        //console.log(`[${this.name}] ssb: get [${index}] '${this.strings[index]}'`);\n        if (!this.enabled) {\n            throw new SmileError('shared strings are not enabled');\n        }\n        if (index >= this.strings.length) {\n            throw new SmileError(`shared string reference out of range`);\n        }\n        return this.strings[index];\n    };\n}\n","import {DecoderStream} from './decoderStream.js';\nimport {InputStream} from './inputStream.js';\nimport {SmileError} from './error.js';\nimport {SharedStringBuffer} from './sharedStringBuffer.js';\nimport {Decoder} from './decoder.js';\n\n/**\n * Parser options.\n */\nexport interface ParserOptions {\n}\n\n/**\n * Parse SMILE-encoded data.\n *\n * @param data SMILE-encoded data\n * @param options parser options\n */\nexport function parse(data: Uint8Array, options?: ParserOptions): any {\n    return new ParserContext(data, options).parse();\n}\n\nclass ParserContext {\n    private readonly decoderStream: DecoderStream;\n    private readonly options?: ParserOptions;\n    private readonly decoder: Decoder;\n    private sharedPropertyName: boolean;\n    private sharedStringValue: boolean;\n    private rawBinary: boolean;\n    private version: number;\n    private sharedPropertyNames: SharedStringBuffer;\n    private sharedStringValues: SharedStringBuffer;\n\n    constructor(data: Uint8Array, options?: ParserOptions) {\n        this.decoderStream = new DecoderStream(new InputStream(data));\n        this.options = options;\n        this.decoder = new Decoder();\n\n        this.sharedPropertyName = false;\n        this.sharedStringValue = false;\n        this.rawBinary = false;\n        this.version = 0;\n\n        // TODO\n        this.sharedPropertyNames = SharedStringBuffer.newKeyNames(false);\n        this.sharedStringValues = SharedStringBuffer.newValues(false);\n    }\n\n    public parse(): any {\n        // parse header\n        const b0 = this.decoderStream.read();\n        const b1 = this.decoderStream.read();\n        const b2 = this.decoderStream.read();\n\n        if ((b0 !== 0x3a) || (b1 !== 0x29) || (b2 !== 0x0a)) {\n            throw new SmileError('invalid Smile header');\n        }\n\n        const b3 = this.decoderStream.read();\n        this.sharedPropertyName = (b3 & 0x01) === 0x01;\n        this.sharedStringValue = (b3 & 0x02) === 0x02;\n        this.rawBinary = (b3 & 0x04) === 0x04;\n        this.version = b3 >> 4;\n\n        this.sharedPropertyNames = SharedStringBuffer.newKeyNames(this.sharedPropertyName);\n        this.sharedStringValues = SharedStringBuffer.newValues(this.sharedStringValue);\n\n        return this.readValue();\n    };\n\n    private readValue(): any {\n        const token = this.decoderStream.read();\n        const tokenClass = token >> 5;\n        const tokenValue = token & 0x1f;\n        switch (tokenClass) {\n            case 0: { // Short Shared Value String reference (single byte)\n                return this.sharedStringValues.getString(tokenValue);\n            }\n            case 1: { // Simple literals, numbers\n                return this.readSimpleLiteralValue(token);\n            }\n            case 2: { // Tiny ASCII (1 - 32 bytes == chars)\n                const value = this.decoderStream.readAscii(tokenValue + 1);\n                this.sharedStringValues.addString(value);\n                return value;\n            }\n            case 3: { // Short ASCII (33 - 64 bytes == chars)\n                const value = this.decoderStream.readAscii(tokenValue + 33);\n                this.sharedStringValues.addString(value);\n                return value;\n            }\n            case 4: { // Tiny Unicode (2 - 33 bytes; <= 33 characters)\n                const value = this.decoderStream.readUtf8(tokenValue + 2);\n                this.sharedStringValues.addString(value);\n                return value;\n            }\n            case 5: { // Short Unicode (34 - 64 bytes; <= 64 characters)\n                const value = this.decoderStream.readUtf8(tokenValue + 34);\n                this.sharedStringValues.addString(value);\n                return value;\n            }\n            case 6: { // Small integers (single byte)\n                return this.decoder.decodeZigZag(tokenValue);\n            }\n            case 7: { // Binary / Long text / structure markers\n                return this.readBinaryLongTextStructureValues(token);\n            }\n            default: {\n                throw new SmileError(`unknown token class: ${tokenClass}`);\n            }\n        }\n    }\n\n    private readSimpleLiteralValue(token: number): any {\n        if (token === 0x20) { // empty string\n            return '';\n        } else if (token === 0x21) { // null\n            return null;\n        } else if (token === 0x22) { // false\n            return false;\n        } else if (token === 0x23) { // true\n            return true;\n        } else if (token === 0x24) { // 32-bit integer; zigzag encoded, 1 - 5 data bytes\n            return this.decoderStream.readSignedVint();\n        } else if (token === 0x25) { // 64-bit integer; zigzag encoded, 5 - 10 data bytes\n            return this.decoderStream.readSignedVint();\n        } else if (token === 0x26) { // BigInteger\n            return this.decoderStream.readBigInt();\n        } else if (token === 0x28) { // 32-bit float\n            return this.decoderStream.readFloat32();\n        } else if (token === 0x29) { // 64-bit double\n            return this.decoderStream.readFloat64();\n        } else if (token === 0x2a) { // BigDecimal\n            return this.decoderStream.readBigDecimal();\n        } else {\n            throw new SmileError('invalid value token 0x' + token.toString(16));\n        }\n    }\n\n    private readBinaryLongTextStructureValues(token: number): any {\n        if (token === 0xe0) { // Long (variable length) ASCII text\n            return this.decoderStream.readLongAscii();\n        } else if (token === 0xe4) { // Long (variable length) Unicode text\n            return this.decoderStream.readLongUtf8();\n        } else if (token === 0xe8) { // Binary, 7-bit encoded\n            return this.decoderStream.readSafeBinary();\n        } else if ((token >= 0xec) && (token <= 0xef)) { // Shared String reference, long\n            const reference = ((token & 0x03) << 8) | this.decoderStream.read();\n            return this.sharedStringValues.getString(reference);\n        } else if (token === 0xf8) { // START_ARRAY\n            const array: any[] = [];\n            while (this.decoderStream.peek() !== 0xf9) { // END_ARRAY\n                array.push(this.readValue());\n            }\n            this.decoderStream.read(); // consume END_ARRAY\n            return array;\n        } else if (token === 0xfa) { // START_OBJECT\n            const object: { [key: string]: any } = {};\n            while (this.decoderStream.peek() !== 0xfb) { // END_OBJECT\n                const key = this.readKey();\n                const value = this.readValue();\n                object[key] = value;\n            }\n            this.decoderStream.read(); // consume END_OBJECT\n            return object;\n        } else if (token === 0xfd) { // Binary (raw)\n            const len = this.decoderStream.readUnsignedVint();\n            if (typeof(len) === 'bigint') {\n                throw new SmileError('invalid length');\n            }\n            return this.decoderStream.readBytes(len);\n        } else {\n            throw new SmileError('invalid value token 0x' + token.toString(16));\n        }\n    }\n\n    private readKey(): string {\n        const token = this.decoderStream.read();\n        if (token === 0x20) { // Special constant name '' (empty String)\n            return '';\n        } else if ((token >= 0x30) && (token <= 0x33)) { // 'Long' shared key name reference (2 byte token)\n            const reference = ((token & 0x03) << 8) | this.decoderStream.read();\n            return this.sharedPropertyNames.getString(reference);\n        } else if (token === 0x34) { // Long (not-yet-shared) Unicode name\n            return this.decoderStream.readLongUtf8();\n        } else if ((token >= 0x40) && (token <= 0x7f)) { // 'Short' shared key name reference\n            const reference = token & 0x3f;\n            return this.sharedPropertyNames.getString(reference);\n        } else if ((token >= 0x80) && (token <= 0xbf)) { // Short Ascii names\n            const s = this.decoderStream.readAscii((token & 0x3f) + 1);\n            this.sharedPropertyNames.addString(s);\n            return s;\n        } else if ((token >= 0xc0) && (token <= 0xf7)) { // Short Unicode names\n            const s = this.decoderStream.readUtf8((token & 0x3f) + 2);\n            this.sharedPropertyNames.addString(s);\n            return s;\n        } else {\n            throw new SmileError('invalid key token 0x' + token.toString(16));\n        }\n    }\n}\n"],"names":["SmileError","msg","bitMask","Decoder","bytes","value","n","v","buffer","view","i","bits","output","iByte","iBitsRemaining","oByte","oBitsWritten","currentInput","currentOutput","oIndex","bitsToWrite","DecoderStream","inputStream","len","scale","c","eofError","InputStream","array","endIndex","readData","SharedStringBuffer","name","keyMode","enabled","maxStrings","s","index","parse","data","options","ParserContext","b0","b1","b2","b3","token","tokenClass","tokenValue","reference","object","key"],"mappings":"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"}