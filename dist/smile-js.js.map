{"version":3,"file":"smile-js.js","sources":["../src/main/js/error.ts","../src/main/js/decoder.ts","../src/main/js/decoderStream.ts","../src/main/js/inputStream.ts","../src/main/js/sharedStringBuffer.ts","../src/main/js/parser.ts"],"sourcesContent":["/**\n * SMILE error.\n */\nexport class SmileError extends Error {\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n","import {SmileError} from './error.js';\n\nconst bitMask = [0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff];\n\nexport class Decoder {\n    public decodeZigZag(value: number): number {\n        if (value < 0) {\n            throw new SmileError(\"illegal zigzag value\");\n        }\n        if (value <= 2147483647) {\n            if (value & 1) {\n                return -(value >> 1) - 1;\n            } else {\n                return (value >> 1);\n            }\n        } else {\n            if (value & 1) {\n                return -(Math.floor(value / 2)) - 1;\n            } else {\n                return Math.floor(value / 2);\n            }\n        }\n    }\n\n    public decodeAscii(bytes: Uint8Array): string {\n        return new TextDecoder('ascii').decode(bytes);\n    }\n\n    public decodeUtf8(bytes: Uint8Array): string {\n        return new TextDecoder('utf8').decode(bytes);\n    }\n\n    private toDataView(bytes: Uint8Array): DataView {\n        const buffer = new ArrayBuffer(bytes.length);\n        const view = new DataView(buffer);\n        for (let i = 0; i < bytes.length; i++) {\n            view.setUint8(i, bytes[i])\n        }\n        return view;\n    }\n\n    // big-endian encoding\n    public decodeFloat32(bytes: Uint8Array): number {\n        return this.toDataView(bytes).getFloat32(0, false);\n    }\n\n    // big-endian encoding\n    public decodeFloat64(bytes: Uint8Array): number {\n        return this.toDataView(bytes).getFloat64(0, false);\n    }\n\n    public decodeFixedLengthBigEndianEncodedBits(bytes: Uint8Array, bits: number): Uint8Array {\n        const output = new Uint8Array(Math.ceil(bits / 8));\n        let iByte = 0;\n        let iBitsRemaining = bits % 7;\n        let oByte = 0;\n        let oBitsWritten = 0;\n        let currentInput = bytes[iByte];\n        let currentOutput = 0;\n        let oIndex;\n        while (iByte < bytes.length) {\n            const bitsToWrite = Math.min(iBitsRemaining, (8 - oBitsWritten));\n            currentOutput <<= bitsToWrite;\n            currentOutput |= currentInput >> (iBitsRemaining - bitsToWrite);\n            iBitsRemaining -= bitsToWrite;\n            currentInput &= bitMask[iBitsRemaining];\n            oBitsWritten += bitsToWrite;\n            if (iBitsRemaining === 0) {\n                iByte++;\n                iBitsRemaining = 7;\n                currentInput = bytes[iByte];\n            }\n            if (oBitsWritten === 8) {\n                oIndex = oByte;\n                output[oIndex] = currentOutput;\n                oByte++;\n                oBitsWritten = 0;\n                currentOutput = 0;\n            }\n        }\n        if (oBitsWritten > 0) {\n            currentOutput <<= (8 - oBitsWritten);\n            oIndex = oByte;\n            output[oIndex] = currentOutput;\n        }\n        return output;\n    }\n\n    public decodeSafeBinaryEncodedBits(bytes: Uint8Array, bits: number): Uint8Array {\n        const output = new Uint8Array(Math.ceil(bits / 8));\n        let iByte = 0;\n        let iBitsRemaining = 7;\n        let oByte = 0;\n        let oBitsWritten = 0;\n        let currentInput = bytes[iByte];\n        let currentOutput = 0;\n        while (oByte < output.length) {\n            const bitsToWrite = Math.min(iBitsRemaining, (8 - oBitsWritten));\n            currentOutput <<= bitsToWrite;\n            currentOutput |= currentInput >> (iBitsRemaining - bitsToWrite);\n            iBitsRemaining -= bitsToWrite;\n            currentInput &= bitMask[iBitsRemaining];\n            oBitsWritten += bitsToWrite;\n            if (iBitsRemaining === 0) {\n                iByte++;\n                iBitsRemaining = 7;\n                currentInput = bytes[iByte];\n            }\n            if (oBitsWritten === 8) {\n                output[oByte] = currentOutput;\n                oByte++;\n                oBitsWritten = 0;\n                currentOutput = 0;\n            }\n        }\n        if (oBitsWritten > 0) {\n            currentOutput <<= (8 - oBitsWritten);\n            output[oByte] = currentOutput;\n        }\n        return output;\n    }\n}\n","import {InputStream} from './inputStream.js';\nimport {Decoder} from './decoder.js';\n\nexport class DecoderStream {\n    private readonly inputStream: InputStream;\n    private readonly decoder: Decoder;\n\n    constructor(inputStream: InputStream) {\n        this.inputStream = inputStream;\n        this.decoder = new Decoder();\n    }\n\n    public isEof(): boolean {\n        return this.inputStream.isEof();\n    }\n\n    public read(): number {\n        return this.inputStream.read();\n    }\n\n    public peek(): number {\n        return this.inputStream.peek();\n    }\n\n    public readUnsignedVint(): number {\n        let value = 0;\n        let bits = 0;\n\n        function safeLeftShift(n: number, shift: number): void {\n            const bitMask = [0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff];\n            const shiftMultiplier = [1, 2, 4, 8, 16, 32, 64, 128];\n\n            if ((bits + shift) < 32) {\n                value <<= shift;\n                value |= n & bitMask[shift];\n            } else {\n                value *= shiftMultiplier[shift];\n                value += n & bitMask[shift];\n            }\n            bits += shift;\n        }\n\n        while (true) {\n            const n = this.inputStream.read();\n            if (n & 0x80) {\n                safeLeftShift(n, 6);\n                return value;\n            } else {\n                safeLeftShift(n, 7);\n            }\n        }\n    }\n\n    public readSignedVint(): number {\n        return this.decoder.decodeZigZag(this.readUnsignedVint());\n    }\n\n    public readAscii(len: number): string {\n        return this.decoder.decodeAscii(this.inputStream.readArray(len));\n    }\n\n    public readUtf8(len: number):string {\n        return this.decoder.decodeUtf8(this.inputStream.readArray(len));\n    }\n\n    public readFloat32(): number {\n        return this.decoder.decodeFloat32(this.readFixedLengthBigEndianEncodedBits(32));\n    }\n\n    public readFloat64(): number {\n        return this.decoder.decodeFloat64(this.readFixedLengthBigEndianEncodedBits(64));\n    }\n\n    public readFixedLengthBigEndianEncodedBits(bits: number): Uint8Array {\n        const bytes = this.inputStream.readArray(Math.ceil(bits / 7));\n        return this.decoder.decodeFixedLengthBigEndianEncodedBits(bytes, bits);\n    }\n\n    public readSafeBinary(): Uint8Array {\n        const len = this.readUnsignedVint();\n        const bytes = this.inputStream.readArray(Math.ceil(len * 8 / 7));\n        return this.decoder.decodeSafeBinaryEncodedBits(bytes, len * 8);\n    }\n\n    public readBigInt(): number {\n        const bytes = this.readSafeBinary();\n        let n = 0;\n        for (let i = 0; i < bytes.length; i++) {\n            n = (n * 256) + bytes[i];\n        }\n        return n;\n    }\n\n    public readBigDecimal(): number {\n        const scale = this.readSignedVint();\n        const magnitude = this.readBigInt();\n        return magnitude * Math.pow(10, scale);\n    }\n\n    public readLongString(): Uint8Array {\n        const buffer: number[] = [];\n        while (true) {\n            const c = this.inputStream.read();\n            if (c === 0xfc) {\n                break;\n            }\n            buffer.push(c);\n        }\n        return new Uint8Array(buffer);\n    }\n\n    public readLongAscii() {\n        return this.decoder.decodeAscii(this.readLongString());\n    }\n\n    public readLongUtf8() {\n        return this.decoder.decodeUtf8(this.readLongString());\n    }\n\n    public readBytes(len: number): Uint8Array {\n        return this.inputStream.readArray(len);\n    }\n}\n","import {SmileError} from './error.js';\n\nexport const eofError = new SmileError('end of input stream reached');\n\nexport class InputStream {\n    private readonly array: Uint8Array;\n    private index: number = 0;\n\n    constructor(array: Uint8Array) {\n        this.array = array;\n    }\n\n    public isEof(): boolean {\n        return (this.index >= this.array.length);\n    }\n\n    public read(): number {\n        if (this.isEof()) {\n            throw eofError;\n        }\n        const v = this.array[this.index];\n        this.index++;\n        return v;\n    }\n\n    public readArray(n: number): Uint8Array {\n        if (this.isEof()) {\n            throw eofError;\n        }\n        if (n < 0) {\n            throw new SmileError('invalid read amount');\n        }\n        const endIndex = Math.min(this.array.length, this.index + n);\n        const readData = this.array.subarray(this.index, endIndex);\n        this.index = endIndex;\n        return readData;\n    }\n\n    public peek(): number {\n        if (this.isEof()) {\n            throw eofError;\n        }\n        return this.array[this.index];\n    }\n\n    public skip(n: number) {\n        if (this.isEof()) {\n            throw eofError;\n        }\n        if (n < 0) {\n            throw new SmileError('invalid skip amount');\n        }\n        this.index += n;\n    }\n}\n","import {SmileError} from './error.js';\n\nexport class SharedStringBuffer {\n    private readonly enabled: boolean;\n    private readonly maxStrings: number;\n    private strings: string[];\n\n    constructor(enabled: boolean, maxStrings: number) {\n        if (maxStrings > 1024) {\n            throw new SmileError('maxStrings must be <= 1024');\n        }\n        this.enabled = enabled;\n        this.maxStrings = maxStrings;\n        this.strings = [];\n    }\n\n    public addString(s: string): number {\n        if (!this.enabled) {\n            return -1;\n        }\n        if (this.strings.length >= this.maxStrings) {\n            this.strings = [];\n        }\n        const index = this.strings.length;\n        this.strings.push(s);\n        return index;\n    };\n\n    public getString(index: number): string {\n        if (!this.enabled) {\n            throw new SmileError('shared strings are not enabled.');\n        }\n        if (index >= this.strings.length) {\n            throw new SmileError('shared string reference out of range.');\n        }\n        return this.strings[index];\n    };\n}\n","import {DecoderStream} from './decoderStream.js';\nimport {InputStream} from './inputStream.js';\nimport {SmileError} from './error.js';\nimport {SharedStringBuffer} from './sharedStringBuffer.js';\nimport {Decoder} from './decoder.js';\n\n/**\n * Parser options.\n */\nexport interface ParserOptions {\n}\n\n/**\n * Parse SMILE-encoded data.\n *\n * @param data SMILE-encoded data\n * @param options parser options\n */\nexport function parse(data: Uint8Array, options?: ParserOptions): any {\n    return new ParserContext(data, options).parse();\n}\n\nclass ParserContext {\n    private readonly decoderStream: DecoderStream;\n    private readonly options?: ParserOptions;\n    private readonly decoder: Decoder;\n    private sharedPropertyName: boolean;\n    private sharedStringValue: boolean;\n    private rawBinary: boolean;\n    private version: number;\n    private sharedPropertyNames: SharedStringBuffer;\n    private sharedStringValues: SharedStringBuffer;\n\n    constructor(data: Uint8Array, options?: ParserOptions) {\n        this.decoderStream = new DecoderStream(new InputStream(data));\n        this.options = options;\n        this.decoder = new Decoder();\n\n        this.sharedPropertyName = false;\n        this.sharedStringValue = false;\n        this.rawBinary = false;\n        this.version = 0;\n\n        // TODO\n        this.sharedPropertyNames = new SharedStringBuffer(false, 1024);\n        this.sharedStringValues = new SharedStringBuffer(false, 1024);\n    }\n\n    public parse(): any {\n        // parse header\n        const b0 = this.decoderStream.read();\n        const b1 = this.decoderStream.read();\n        const b2 = this.decoderStream.read();\n\n        if ((b0 !== 0x3a) || (b1 !== 0x29) || (b2 !== 0x0a)) {\n            throw new SmileError('invalid Smile header');\n        }\n\n        const b3 = this.decoderStream.read();\n        this.sharedPropertyName = (b3 & 0x01) === 0x01;\n        this.sharedStringValue = (b3 & 0x02) === 0x02;\n        this.rawBinary = (b3 & 0x04) === 0x04;\n        this.version = b3 >> 4;\n\n        this.sharedPropertyNames = new SharedStringBuffer(this.sharedPropertyName, 1024);\n        this.sharedStringValues = new SharedStringBuffer(this.sharedStringValue, 1024);\n\n        return this.readValue();\n    };\n\n    private readValue(): any {\n        const token = this.decoderStream.read();\n        const tokenClass = token >> 5;\n        const tokenValue = token & 0x1f;\n        switch (tokenClass) {\n            case 0: { // Short Shared Value String reference (single byte)\n                return this.sharedStringValues.getString(tokenValue);\n            }\n            case 1: { // Simple literals, numbers\n                return this.readSimpleLiteralValue(token);\n            }\n            case 2: { // Tiny ASCII (1 - 32 bytes == chars)\n                const value = this.decoderStream.readAscii(tokenValue + 1);\n                this.sharedStringValues.addString(value);\n                return value;\n            }\n            case 3: { // Short ASCII (33 - 64 bytes == chars)\n                const value = this.decoderStream.readAscii(tokenValue + 33);\n                this.sharedStringValues.addString(value);\n                return value;\n            }\n            case 4: { // Tiny Unicode (2 - 33 bytes; <= 33 characters)\n                const value = this.decoderStream.readUtf8(tokenValue + 2);\n                this.sharedStringValues.addString(value);\n                return value;\n            }\n            case 5: { // Short Unicode (34 - 64 bytes; <= 64 characters)\n                const value = this.decoderStream.readUtf8(tokenValue + 34);\n                this.sharedStringValues.addString(value);\n                return value;\n            }\n            case 6: { // Small integers (single byte)\n                return this.decoder.decodeZigZag(tokenValue);\n            }\n            case 7: { // Binary / Long text / structure markers\n                return this.readBinaryLongTextStructureValues(token);\n            }\n            default: {\n                throw new SmileError(`unknown token class: ${tokenClass}`);\n            }\n        }\n    }\n\n    private readSimpleLiteralValue(token: number): any {\n        if (token === 0x20) { // empty string\n            return '';\n        } else if (token === 0x21) { // null\n            return null;\n        } else if (token === 0x22) { // false\n            return false;\n        } else if (token === 0x23) { // true\n            return true;\n        } else if (token === 0x24) { // 32-bit integer; zigzag encoded, 1 - 5 data bytes\n            return this.decoderStream.readSignedVint();\n        } else if (token === 0x25) { // 64-bit integer; zigzag encoded, 5 - 10 data bytes\n            return this.decoderStream.readSignedVint();\n        } else if (token === 0x26) { // BigInteger\n            return this.decoderStream.readBigInt();\n        } else if (token === 0x28) { // 32-bit float\n            return this.decoderStream.readFloat32();\n        } else if (token === 0x29) { // 64-bit double\n            return this.decoderStream.readFloat64();\n        } else if (token === 0x2a) { // BigDecimal\n            return this.decoderStream.readBigDecimal();\n        } else {\n            throw new SmileError('invalid value token 0x' + token.toString(16));\n        }\n    }\n\n    private readBinaryLongTextStructureValues(token: number): any {\n        if (token === 0xe0) { // Long (variable length) ASCII text\n            return this.decoderStream.readLongAscii();\n        } else if (token === 0xe4) { // Long (variable length) Unicode text\n            return this.decoderStream.readLongUtf8();\n        } else if (token === 0xe8) { // Binary, 7-bit encoded\n            return this.decoderStream.readSafeBinary();\n        } else if ((token >= 0xec) && (token <= 0xef)) { // Shared String reference, long\n            const reference = ((token & 0x03) << 8) | this.decoderStream.read();\n            if (reference < 64) {\n                throw new SmileError('invalid long shared value name reference');\n            }\n            return this.sharedStringValues.getString(reference);\n        } else if (token === 0xf8) { // START_ARRAY\n            const array: any[] = [];\n            while (this.decoderStream.peek() !== 0xf9) { // END_ARRAY\n                array.push(this.readValue());\n            }\n            this.decoderStream.read(); // consume END_ARRAY\n            return array;\n        } else if (token === 0xfa) { // START_OBJECT\n            const object: { [key: string]: any } = {};\n            while (this.decoderStream.peek() !== 0xfb) { // END_OBJECT\n                const key = this.readKey();\n                const value = this.readValue();\n                object[key] = value;\n            }\n            this.decoderStream.read(); // consume END_OBJECT\n            return object;\n        } else if (token === 0xfd) { // Binary (raw)\n            const len = this.decoderStream.readUnsignedVint();\n            return this.decoderStream.readBytes(len);\n        } else {\n            throw new SmileError('invalid value token 0x' + token.toString(16));\n        }\n    }\n\n    private readKey(): string {\n        const token = this.decoderStream.read();\n        if (token === 0x20) { // Special constant name '' (empty String)\n            return '';\n        } else if ((token >= 0x30) && (token <= 0x33)) { // 'Long' shared key name reference (2 byte token)\n            const reference = ((token & 0x03) << 8) | this.decoderStream.read();\n            if (reference < 64) {\n                throw new SmileError('invalid long shared key name reference.');\n            }\n            return this.sharedPropertyNames.getString(reference);\n        } else if (token === 0x34) { // Long (not-yet-shared) Unicode name\n            return this.decoderStream.readLongUtf8();\n        } else if ((token >= 0x40) && (token <= 0x7f)) { // 'Short' shared key name reference\n            const reference = token & 0x3f;\n            return this.sharedPropertyNames.getString(reference);\n        } else if ((token >= 0x80) && (token <= 0xbf)) { // Short Ascii names\n            const s = this.decoderStream.readAscii((token & 0x3f) + 1);\n            this.sharedPropertyNames.addString(s);\n            return s;\n        } else if ((token >= 0xc0) && (token <= 0xf7)) { // Short Unicode names\n            const s = this.decoderStream.readUtf8((token & 0x3f) + 2);\n            this.sharedPropertyNames.addString(s);\n            return s;\n        } else {\n            throw new SmileError('invalid key token 0x' + token.toString(16));\n        }\n    }\n}\n"],"names":["SmileError","msg","bitMask","Decoder","value","bytes","buffer","view","i","bits","output","iByte","iBitsRemaining","oByte","oBitsWritten","currentInput","currentOutput","oIndex","bitsToWrite","DecoderStream","inputStream","safeLeftShift","n","shift","shiftMultiplier","len","scale","c","eofError","InputStream","array","v","endIndex","readData","SharedStringBuffer","enabled","maxStrings","s","index","parse","data","options","ParserContext","b0","b1","b2","b3","token","tokenClass","tokenValue","reference","object","key"],"mappings":"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"}